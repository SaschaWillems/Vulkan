#version 450

#define INT64 0

#if INT64
#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_buffer_reference : require
#else
#extension GL_EXT_buffer_reference_uvec2 : require
#endif

layout(buffer_reference) buffer Pos {
   uint values[ ];
};

layout (push_constant) uniform PushConsts {
#if INT64
	uint64_t address;
#else
	uvec2 address;
#endif
} pushConsts;

#if INT64
#define low32(address) uint((address) & 0xffffffff)
#define high32(address) uint(((address) >> 32) & 0xffffffff)
#else
#define low32(address) uint((address).x)
#define high32(address) uint((address).y)
#endif

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (constant_id = 0) const uint BUFFER_ELEMENTS = 32;

uint fibonacci(uint n) {
	if(n <= 1){
		return n;
	}
	uint curr = 1;
	uint prev = 1;
	for(uint i = 2; i < n; ++i) {
		uint temp = curr;
		curr += prev;
		prev = temp;
	}
	return curr;
}

void main() 
{
	uint index = gl_GlobalInvocationID.x;
	if (index >= BUFFER_ELEMENTS) 
		return;
	// uint64_t a0 = 0xffffb000;
	// uint64_t a1 = 0xfffffffe;
	// uint64_t address = (a1 << 32) | a0;
	// uint64_t address = 0x2bffff000UL;
	Pos pos1 = Pos(pushConsts.address);
	pos1.values[index] = fibonacci(pos1.values[index]);
	if (index == 31) {
		pos1.values[index] = low32(pushConsts.address);
	}
	else if (index == 30) {
		pos1.values[index] = high32(pushConsts.address);
	}
	// if (index == 31) {
	// 	values[index] = pushConsts.address0;
	// }
	// else if (index == 30) {
	// 	values[index] = pushConsts.address1;
	// }
	// else {
	// 	values[index] = fibonacci(values[index]);
	// }
	if (index == 0) {
		pos1.values[index] = 2444;
	}
	// memoryBarrier();
	// barrier();
	// if (index == 31) {
	// 	values[index] = values[15];
	// }
	// pos1.values[index] = pos1.values[index] ^ 1;
}

